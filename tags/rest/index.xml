<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>REST on 细雨听风</title>
    <link>https://jxlnssyly.github.io/tags/rest/</link>
    <description>Recent content in REST on 细雨听风</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-ch</language>
    <lastBuildDate>Thu, 14 Nov 2019 21:57:52 +0800</lastBuildDate>
    
	<atom:link href="https://jxlnssyly.github.io/tags/rest/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1、初步认识REST</title>
      <link>https://jxlnssyly.github.io/1.%E8%AE%A4%E8%AF%86restapi/</link>
      <pubDate>Thu, 14 Nov 2019 21:57:52 +0800</pubDate>
      
      <guid>https://jxlnssyly.github.io/1.%E8%AE%A4%E8%AF%86restapi/</guid>
      <description> REST是什么?  REST是一种架构风格，万维网软件架构风格 用来创建网络服务的  为什么叫 REST?  Representational State Transfer Representational:数据的表现形式 State: 当前状态或者数据 Transfer: 数据传输  REST的6个限制 1、客户端-服务器(Client - Server)
* 关注点分离 * 服务端专注数据存储，提升了简单性 * 前端专注用户界面，提升了可移植性  2、无状态(Stateless)
* 所有用户会话信息都保存在客户端 * 每次请求必须包括所有信息，不能依赖上下文信息 * 服务端不用保存会话信息，提升了简单性、可靠性、可见性  3、缓存
* 所有服务端响应都要标为可缓存或不可缓存 * 减少前后端交互，提升了性能  4、统一接口(Uniform Interface)
* 接口设计尽可能统一通用，提升了简单性，可见性 * 接口与实现解耦，使前后端可以独立开发迭代  5、分层系统(Layered System)
* 每层只知道相邻的一层，后面隐藏的就不知道了 * 客户端不知道是和代理还是真实服务器通信 * 其它层: 安全层、负载均衡、缓存层等  6、按需代码(Code-On-Demand可选)
* 客户端可以下载运行服务端传来的代码(比如JS) * 通过减少一些功能，简化了客户端  </description>
    </item>
    
    <item>
      <title>1、初步认识REST</title>
      <link>https://jxlnssyly.github.io/1.%E8%AE%A4%E8%AF%86restapi/</link>
      <pubDate>Thu, 14 Nov 2019 21:57:52 +0800</pubDate>
      
      <guid>https://jxlnssyly.github.io/1.%E8%AE%A4%E8%AF%86restapi/</guid>
      <description> REST是什么?  REST是一种架构风格，万维网软件架构风格 用来创建网络服务的  为什么叫 REST?  Representational State Transfer Representational:数据的表现形式 State: 当前状态或者数据 Transfer: 数据传输  REST的6个限制 1、客户端-服务器(Client - Server)
* 关注点分离 * 服务端专注数据存储，提升了简单性 * 前端专注用户界面，提升了可移植性  2、无状态(Stateless)
* 所有用户会话信息都保存在客户端 * 每次请求必须包括所有信息，不能依赖上下文信息 * 服务端不用保存会话信息，提升了简单性、可靠性、可见性  3、缓存
* 所有服务端响应都要标为可缓存或不可缓存 * 减少前后端交互，提升了性能  4、统一接口(Uniform Interface)
* 接口设计尽可能统一通用，提升了简单性，可见性 * 接口与实现解耦，使前后端可以独立开发迭代  5、分层系统(Layered System)
* 每层只知道相邻的一层，后面隐藏的就不知道了 * 客户端不知道是和代理还是真实服务器通信 * 其它层: 安全层、负载均衡、缓存层等  6、按需代码(Code-On-Demand可选)
* 客户端可以下载运行服务端传来的代码(比如JS) * 通过减少一些功能，简化了客户端  </description>
    </item>
    
  </channel>
</rss>